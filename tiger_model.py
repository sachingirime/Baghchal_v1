# -*- coding: utf-8 -*-
"""tiger_model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I1NtDumyYmiAWSe03YfUj2s8JD29VjVl
"""

import random
import numpy as np
import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.backend import reshape
from keras.utils.np_utils import to_categorical
import os


import tensorflow as tf

model = tf.keras.models.load_model('model_v1')

# Check its architecture
model.summary()

tiger_objects = [100,101,102,103]  #tiger objects/first digit(1) reresenting tiger type
goat_objects = [200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219] # goat objects/ first digit(2) representing goat type

#function which takes current position of player and present board condition and gives all empty positions as well as occupied positions to move for player
def player_position(board,player_position):
  pos_link =     [{'00':['01','10','11'],'01':['00','02','11'],'02':['01','03','11','12','14','13'],'03':['02','04','13'],'04':['03','14','13']},
                  {'10':['00','20','11'],'11':['00','01','02','10','12','20','21','22'],'12':['02','11','13','22'],'13':['02','03','04','12','14','22','23','24'],'14':['04','13','24']},
                  {'20':['10','11','21','30','31'],'21':['11','20','22','31'],'22':['11','12','13','21','23','31','32','33'],'23':['13','22','24','33'],'24':['13','14','23','33','34']},
                  {'30':['20','31','40'],'31':['20','21','22','30','32','40','41','42'],'32':['22','31','33','42'],'33':['22','23','24','32','34','42','43','44'],'34':['24','33','44']},
                  {'40':['30','31','41'],'41':['31','40','42'],'42':['31','32','33','41','43'],'43':['33','42','44'],'44':['33','34','43']}]
  free_position = []
  taken_position = []
  for dicts in pos_link:
    for k,v in dicts.items():
      if k == player_position:
        for p in v:
          m,n=map(int,[char for char in p])
          if board[m][n] == 0:
            free_position.append(p)
          else:
            taken_position.append(p)
                  
  return ((taken_position,free_position))

#function for tiger jump

def tiger_jump(board,tiger_position):
    
  possible_jumps = []
  
  
  first_occupied, _ = player_position(board,tiger_position) # step 1
  
  for pos in first_occupied:        #step 2
      
    index = list(map(int,pos))
    for g in goat_objects:
      if board[index[0]][index[1]] == g:
        goat_index= index
        goat_position = str(goat_index[0]) + str(goat_index[1])

        _ , second_free = player_position(board, goat_position) # step 3

        first_difference = ( abs(int(tiger_position[0]) - int(goat_position[0])), abs(int(tiger_position[1]) - int(goat_position[1])) )

        for pos_2 in second_free:   #step 4

          second_difference = ( abs( int(goat_position[0]) - int(pos_2[0]) ) , abs( int(goat_position[1]) - int(pos_2[1]) )   )

          if (first_difference == second_difference == (0,1)):
            possible_jumps.append(pos_2)

          elif (first_difference == second_difference == (1,0) ):
            possible_jumps.append(pos_2)

          elif ( first_difference == second_difference == (1,1)):    #step 5
            diagonal_position = pos_2

            if (tiger_position[0] == diagonal_position[0]) or (tiger_position[1] == diagonal_position[1]):
              continue
            else:
              possible_jumps.append(diagonal_position)
  #print('possible_jumps-- insisde tiger jump ', possible_jumps)
  return(possible_jumps)

#returns all tiger moves in a given board state

def tiger_moves(board):
  
  tiger_moves = []
  
  for i in range(len(board)):
        
    for j in range(len(board[i])):
      if str(board[i][j])[0] == '1':
        moves = []
        index = str(i) + str(j)
        _,moves = player_position(board,index)
        jumps = tiger_jump(board,index)
        available_moves = moves + jumps
        
        if len(available_moves) != 0:
          for m in available_moves:
            a,b = tuple(map(int,m))
            tiger_moves.append((a,b))

  return(tiger_moves)

# function returns tiger index which is applicable for move predicted by the model

def final_tiger_move(board,move):
  all_player = []
  tiger =[]
  for t in tiger_objects:
    for i in range(len(board)):
      for j in range(len(board[i])):
        if board[i][j] == t:
          index = str(i) + str(j)
          _,moves = player_position(board,index)
          jumps = tiger_jump(board,index)
          available_moves = moves+jumps
          all_player.append((index,available_moves))

  for player in all_player:
    index = player[0]
    moves = player[1]
    m = str(move[0]) + str(move[1])
    if m in moves:
      a,b = tuple(map(int,index))
      tiger.append((a,b))

  if len(tiger) > 1:
    return(random.choice(tiger))

  
  return(tiger[0])

#best move for tiger---- tiger model----

random.seed()


def best_tiger_move(board, model,  rnd=0):
    scores = []
    best_move = ()
    moves = tiger_moves(board)
    #print('moves',moves)
    if len(moves) != 0:
    # Make predictions for each possible move
      for i in range(len(moves)):
          future = np.array(board)
          future[moves[i][0]][moves[i][1]] = 100
          prediction = model.predict(future.reshape((-1, 25)))[0]
          
          
          winPrediction = prediction[0]
          lossPrediction = prediction[1]
    
          drawPrediction = prediction[2]
          if winPrediction - lossPrediction > 0:
              scores.append(winPrediction - lossPrediction)
          else:
              scores.append(drawPrediction - lossPrediction)
     
      # Choose the best move with a random factor
      bestMoves = np.flip(np.argsort(scores))
      
      for i in range(len(bestMoves)):
          if random.random() * rnd < 0.5:
              best_move = moves[bestMoves[i]]

      # Choose a move completely at random
      if len(best_move) == 0:
        best_move =  moves[random.randint(0, len(moves) - 1)]
  
    tiger_index = final_tiger_move(board,best_move)
    return([tiger_index,best_move])

# try your board here 

board1 = [[213,100,219,205,0],[102,210,0,0,101],[213,0,215,207,0],[0,214,217,203,0],[0,0,103,209,218]]
model_prediction = best_tiger_move(board1,model)
print("Best move for tiger")
print(model_prediction)

